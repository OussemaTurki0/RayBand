import type { JSONValue } from './types';
export declare const nanoid: (size?: number) => string;
declare function createChunkDecoder(complex?: boolean): (chunk: Uint8Array | undefined) => any;
export { createChunkDecoder };
/**
 * The map of prefixes for data in the stream
 *
 * - 0: Text from the LLM response
 * - 1: (OpenAI) function_call responses
 * - 2: custom JSON added by the user using `Data`
 *
 * Example:
 * ```
 * 0:Vercel
 * 0:'s
 * 0: AI
 * 0: AI
 * 0: SDK
 * 0: is great
 * 0:!
 * 2: { "someJson": "value" }
 * 1: {"function_call": {"name": "get_current_weather", "arguments": "{\\n\\"location\\": \\"Charlottesville, Virginia\\",\\n\\"format\\": \\"celsius\\"\\n}"}}
 *```
 */
export declare const StreamStringPrefixes: {
    readonly text: 0;
    readonly function_call: 1;
    readonly data: 2;
};
export declare const isStreamStringEqualToType: (type: keyof typeof StreamStringPrefixes, value: string) => value is `0:${string}\n` | `1:${string}\n` | `2:${string}\n`;
/**
 * Prepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it, and appends a new line.
 */
export declare const getStreamString: (type: keyof typeof StreamStringPrefixes, value: JSONValue) => StreamString;
export type StreamString = `${(typeof StreamStringPrefixes)[keyof typeof StreamStringPrefixes]}:${string}\n`;
export declare const getStreamStringTypeAndValue: (line: string) => {
    type: keyof typeof StreamStringPrefixes;
    value: string;
};
/**
 * A header sent to the client so it knows how to handle parsing the stream (as a deprecated text response or using the new prefixed protocol)
 */
export declare const COMPLEX_HEADER = "X-Experimental-Stream-Data";
//# sourceMappingURL=utils.d.ts.map