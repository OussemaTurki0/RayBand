"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StreamStringPrefixes = exports.COMPLEX_HEADER = void 0;
exports.createChunkDecoder = createChunkDecoder;
exports.nanoid = exports.isStreamStringEqualToType = exports.getStreamStringTypeAndValue = exports.getStreamString = void 0;
var _nonSecure = require("nanoid/non-secure");
// 7-character random string
const nanoid = exports.nanoid = (0, _nonSecure.customAlphabet)('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 7);

// Type overloads
// FIXME: Uncomment this when the complex decoder implemented in all framework files.
// function createChunkDecoder(): (chunk: Uint8Array | undefined) => string
// function createChunkDecoder(
//   complex?: false
// ): (chunk: Uint8Array | undefined) => string
// function createChunkDecoder(complex?: true): (
//   chunk: Uint8Array | undefined
// ) => {
//   type: keyof typeof StreamStringPrefixes
//   value: string
// }[]

function createChunkDecoder(complex) {
  const decoder = new TextDecoder();
  if (!complex) {
    return function (chunk) {
      if (!chunk) return '';
      return decoder.decode(chunk, {
        stream: true
      });
    };
  }
  return function (chunk) {
    const decoded = decoder.decode(chunk, {
      stream: true
    }).split('\n');
    return decoded.map(getStreamStringTypeAndValue).filter(Boolean);
  };
}
/**
 * The map of prefixes for data in the stream
 *
 * - 0: Text from the LLM response
 * - 1: (OpenAI) function_call responses
 * - 2: custom JSON added by the user using `Data`
 *
 * Example:
 * ```
 * 0:Vercel
 * 0:'s
 * 0: AI
 * 0: AI
 * 0: SDK
 * 0: is great
 * 0:!
 * 2: { "someJson": "value" }
 * 1: {"function_call": {"name": "get_current_weather", "arguments": "{\\n\\"location\\": \\"Charlottesville, Virginia\\",\\n\\"format\\": \\"celsius\\"\\n}"}}
 *```
 */
const StreamStringPrefixes = exports.StreamStringPrefixes = {
  text: 0,
  function_call: 1,
  data: 2
  // user_err: 3?
};

const isStreamStringEqualToType = (type, value) => value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith('\n');

/**
 * Prepends a string with a prefix from the `StreamChunkPrefixes`, JSON-ifies it, and appends a new line.
 */
exports.isStreamStringEqualToType = isStreamStringEqualToType;
const getStreamString = (type, value) => `${StreamStringPrefixes[type]}:${JSON.stringify(value)}\n`;
exports.getStreamString = getStreamString;
const getStreamStringTypeAndValue = line => {
  // const split = line.split(':', 2)
  const firstSeperatorIndex = line.indexOf(':');
  const prefix = line.slice(0, firstSeperatorIndex);
  const type = Object.keys(StreamStringPrefixes).find(key => StreamStringPrefixes[key] === Number(prefix));
  const val = line.slice(firstSeperatorIndex + 1);
  let parsedVal = val;
  if (!val) {
    return {
      type,
      value: ''
    };
  }
  try {
    parsedVal = JSON.parse(val);
  } catch (e) {
    console.error('Failed to parse JSON value:', val);
  }
  return {
    type,
    value: parsedVal
  };
};

/**
 * A header sent to the client so it knows how to handle parsing the stream (as a deprecated text response or using the new prefixed protocol)
 */
exports.getStreamStringTypeAndValue = getStreamStringTypeAndValue;
const COMPLEX_HEADER = exports.COMPLEX_HEADER = 'X-Experimental-Stream-Data';
//# sourceMappingURL=utils.js.map