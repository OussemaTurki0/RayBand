"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useChat = useChat;
var _react = require("react");
var _swr = _interopRequireDefault(require("swr"));
var _utils = require("./shared/utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// @ts-ignore

const getResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, onFinish, onResponse, sendExtraMessageFields) => {
  var _chatRequest$options, _chatRequest$options2;
  // Do an optimistic update to the chat state to show the updated messages
  // immediately.
  const previousMessages = messagesRef.current;
  mutate(chatRequest.messages, false);
  const res = await fetch(api, {
    method: 'POST',
    body: JSON.stringify({
      messages: sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(_ref => {
        let {
          role,
          content,
          name,
          function_call
        } = _ref;
        return {
          role,
          content,
          ...(name !== undefined && {
            name
          }),
          ...(function_call !== undefined && {
            function_call: function_call
          })
        };
      }),
      ...extraMetadataRef.current.body,
      ...((_chatRequest$options = chatRequest.options) === null || _chatRequest$options === void 0 ? void 0 : _chatRequest$options.body),
      ...(chatRequest.functions !== undefined && {
        functions: chatRequest.functions
      }),
      ...(chatRequest.function_call !== undefined && {
        function_call: chatRequest.function_call
      })
    }),
    credentials: extraMetadataRef.current.credentials,
    headers: {
      ...extraMetadataRef.current.headers,
      ...((_chatRequest$options2 = chatRequest.options) === null || _chatRequest$options2 === void 0 ? void 0 : _chatRequest$options2.headers)
    },
    ...(abortControllerRef.current !== null && {
      signal: abortControllerRef.current.signal
    })
  }).catch(err => {
    // Restore the previous messages if the request fails.
    console.error(err);
    mutate(previousMessages, false);
    throw err;
  });
  if (onResponse) {
    try {
      await onResponse(res);
    } catch (err) {
      throw err;
    }
  }
  if (!res.ok) {
    // Restore the previous messages if the request fails.
    mutate(previousMessages, false);
    throw new Error((await res.text()) || 'Failed to fetch the chat response.');
  }

  // if (!res.body) {
  //   throw new Error("The response body is empty.");
  // }

  const createdAt = new Date();
  const reader = await res.json();

  // TODO-STREAMDATA: Remove this once Strem Data is not experimental
  let streamedResponse = '';
  const replyId = (0, _utils.nanoid)();
  let responseMessage = {
    id: replyId,
    createdAt,
    content: '',
    role: 'assistant'
  };
  responseMessage.content = reader.data.content;
  mutate([...chatRequest.messages, responseMessage], false);

  // The request has been aborted, stop reading the stream.
  if (abortControllerRef.current === null) {
    reader.cancel();
  }
  // end web

  if (streamedResponse.startsWith('{"function_call":')) {
    // Once the stream is complete, the function call is parsed into an object.
    const parsedFunctionCall = JSON.parse(streamedResponse).function_call;
    responseMessage.function_call = parsedFunctionCall;
    mutate([...chatRequest.messages, {
      ...responseMessage
    }]);
  }
  if (onFinish) {
    onFinish(responseMessage);
  }
  return responseMessage;
};
function useChat() {
  let {
    api = '/api/chat',
    id,
    initialMessages = [],
    initialInput = '',
    sendExtraMessageFields,
    experimental_onFunctionCall,
    onResponse,
    onFinish,
    onError,
    credentials,
    headers,
    body
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // Generate a unique id for the chat if not provided.
  const hookId = (0, _react.useId)();
  const chatId = id || hookId;

  // Store the chat state in SWR, using the chatId as the key to share states.
  const {
    data: messages,
    mutate
  } = (0, _swr.default)([api, chatId], null, {
    fallbackData: initialMessages
  });

  // We store loading state in another hook to sync loading states across hook invocations
  const {
    data: isLoading = false,
    mutate: mutateLoading
  } = (0, _swr.default)([chatId, 'loading'], null);
  const {
    data: streamData,
    mutate: mutateStreamData
  } = (0, _swr.default)([chatId, 'streamData'], null);

  // Keep the latest messages in a ref.
  const messagesRef = (0, _react.useRef)(messages || []);
  (0, _react.useEffect)(() => {
    messagesRef.current = messages || [];
  }, [messages]);

  // Abort controller to cancel the current API call.
  const abortControllerRef = (0, _react.useRef)(null);
  const extraMetadataRef = (0, _react.useRef)({
    credentials,
    headers,
    body
  });
  (0, _react.useEffect)(() => {
    extraMetadataRef.current = {
      credentials,
      headers,
      body
    };
  }, [credentials, headers, body]);

  // Actual mutation hook to send messages to the API endpoint and update the
  // chat state.
  const [error, setError] = (0, _react.useState)();
  const triggerRequest = (0, _react.useCallback)(async chatRequest => {
    try {
      mutateLoading(true);
      setError(undefined);
      const abortController = new AbortController();
      abortControllerRef.current = abortController;
      while (true) {
        // TODO-STREAMDATA: This should be {  const { messages: streamedResponseMessages, data } =
        // await getStreamedResponse(} once Stream Data is not experimental
        const messagesAndDataOrJustMessage = await getResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, onFinish, onResponse, sendExtraMessageFields);

        // Using experimental stream data
        if ('messages' in messagesAndDataOrJustMessage) {
          let hasFollowingResponse = false;
          //@ts-ignore
          for (const message of messagesAndDataOrJustMessage.messages) {
            if (message.function_call === undefined || typeof message.function_call === 'string') {
              continue;
            }
            hasFollowingResponse = true;
            // Streamed response is a function call, invoke the function call handler if it exists.
            if (experimental_onFunctionCall) {
              const functionCall = message.function_call;

              // User handles the function call in their own functionCallHandler.
              // The "arguments" key of the function call object will still be a string which will have to be parsed in the function handler.
              // If the "arguments" JSON is malformed due to model error the user will have to handle that themselves.

              const functionCallResponse = await experimental_onFunctionCall(messagesRef.current, functionCall);

              // If the user does not return anything as a result of the function call, the loop will break.
              if (functionCallResponse === undefined) break;

              // A function call response was returned.
              // The updated chat with function call response will be sent to the API in the next iteration of the loop.
              chatRequest = functionCallResponse;
            }
          }
          if (!hasFollowingResponse) {
            break;
          }
        } else {
          const streamedResponseMessage = messagesAndDataOrJustMessage;
          // TODO-STREAMDATA: Remove this once Stream Data is not experimental
          if (streamedResponseMessage.function_call === undefined || typeof streamedResponseMessage.function_call === 'string') {
            break;
          }

          // Streamed response is a function call, invoke the function call handler if it exists.
          if (experimental_onFunctionCall) {
            const functionCall = streamedResponseMessage.function_call;
            const functionCallResponse = await experimental_onFunctionCall(messagesRef.current, functionCall);

            // If the user does not return anything as a result of the function call, the loop will break.
            if (functionCallResponse === undefined) break;
            // A function call response was returned.
            // The updated chat with function call response will be sent to the API in the next iteration of the loop.
            chatRequest = functionCallResponse;
          }
        }
      }
      abortControllerRef.current = null;
    } catch (err) {
      // Ignore abort errors as they are expected.
      if (err.name === 'AbortError') {
        abortControllerRef.current = null;
        return null;
      }
      if (onError && err instanceof Error) {
        onError(err);
      }
      setError(err);
    } finally {
      mutateLoading(false);
    }
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [mutate, mutateLoading, api, extraMetadataRef, onResponse, onFinish, onError, setError, mutateStreamData, streamData, sendExtraMessageFields, experimental_onFunctionCall, messagesRef.current, abortControllerRef.current]);
  const append = (0, _react.useCallback)(async function (message) {
    let {
      options,
      functions,
      function_call
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (!message.id) {
      message.id = (0, _utils.nanoid)();
    }
    const chatRequest = {
      messages: messagesRef.current.concat(message),
      options,
      ...(functions !== undefined && {
        functions
      }),
      ...(function_call !== undefined && {
        function_call
      })
    };
    return triggerRequest(chatRequest);
  }, [triggerRequest]);
  const reload = (0, _react.useCallback)(async function () {
    let {
      options,
      functions,
      function_call
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (messagesRef.current.length === 0) return null;

    // Remove last assistant message and retry last user message.
    const lastMessage = messagesRef.current[messagesRef.current.length - 1];
    if (lastMessage.role === 'assistant') {
      const chatRequest = {
        messages: messagesRef.current.slice(0, -1),
        options,
        ...(functions !== undefined && {
          functions
        }),
        ...(function_call !== undefined && {
          function_call
        })
      };
      return triggerRequest(chatRequest);
    }
    const chatRequest = {
      messages: messagesRef.current,
      options,
      ...(functions !== undefined && {
        functions
      }),
      ...(function_call !== undefined && {
        function_call
      })
    };
    return triggerRequest(chatRequest);
  }, [triggerRequest]);
  const stop = (0, _react.useCallback)(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
  }, []);
  const setMessages = (0, _react.useCallback)(messages => {
    mutate(messages, false);
    messagesRef.current = messages;
  }, [mutate]);

  // Input state and handlers.
  const [input, setInput] = (0, _react.useState)(initialInput);
  const handleSubmit = (0, _react.useCallback)(function (e) {
    let {
      options,
      functions,
      function_call
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let metadata = arguments.length > 2 ? arguments[2] : undefined;
    if (metadata) {
      extraMetadataRef.current = {
        ...extraMetadataRef.current,
        ...metadata
      };
    }
    if (!input) return;
    append({
      content: input,
      role: 'user',
      createdAt: new Date()
    }, {
      options,
      functions,
      function_call
    });
    setInput('');
  }, [input, append]);
  const handleInputChange = e => {
    setInput(e);
  };
  return {
    messages: messages || [],
    error,
    append,
    reload,
    stop,
    setMessages,
    input,
    setInput,
    handleInputChange,
    handleSubmit,
    isLoading,
    data: streamData
  };
}
//# sourceMappingURL=use-chat.js.map