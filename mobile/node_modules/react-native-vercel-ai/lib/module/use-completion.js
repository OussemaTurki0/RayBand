import { useCallback, useEffect, useId, useRef, useState } from 'react';
import useSWR from 'swr';
export function useCompletion() {
  let {
    api = '/api/completion',
    id,
    initialCompletion = '',
    initialInput = '',
    credentials,
    headers,
    body,
    onResponse,
    onFinish,
    onError
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // Generate an unique id for the completion if not provided.
  const hookId = useId();
  const completionId = id || hookId;

  // Store the completion state in SWR, using the completionId as the key to share states.
  const {
    data,
    mutate
  } = useSWR([api, completionId], null, {
    fallbackData: initialCompletion
  });
  const {
    data: isLoading = false,
    mutate: mutateLoading
  } = useSWR([completionId, 'loading'], null);
  const [error, setError] = useState(undefined);
  const completion = data;

  // Abort controller to cancel the current API call.
  const [abortController, setAbortController] = useState(null);
  const extraMetadataRef = useRef({
    credentials,
    headers,
    body
  });
  useEffect(() => {
    extraMetadataRef.current = {
      credentials,
      headers,
      body
    };
  }, [credentials, headers, body]);
  const triggerRequest = useCallback(async (prompt, options) => {
    try {
      mutateLoading(true);
      setError(undefined);
      const abortController = new AbortController();
      setAbortController(abortController);

      // Empty the completion immediately.
      mutate('', false);
      const res = await fetch(api, {
        method: 'POST',
        body: JSON.stringify({
          prompt,
          ...extraMetadataRef.current.body,
          ...(options === null || options === void 0 ? void 0 : options.body)
        }),
        credentials: extraMetadataRef.current.credentials,
        headers: {
          ...extraMetadataRef.current.headers,
          ...(options === null || options === void 0 ? void 0 : options.headers)
        },
        signal: abortController.signal
      }).catch(err => {
        throw err;
      });
      if (onResponse) {
        try {
          await onResponse(res);
        } catch (err) {
          throw err;
        }
      }
      if (!res.ok) {
        throw new Error((await res.text()) || 'Failed to fetch the chat response.');
      }

      // if (!res.body) {
      //   throw new Error("The response body is empty.");
      // }

      const reader = await res.json();
      mutate(reader.data.content, false);
      if (onFinish) {
        onFinish(prompt, reader.data.content);
      }
      setAbortController(null);
      return reader.data.content;
    } catch (err) {
      // Ignore abort errors as they are expected.
      if (err.name === 'AbortError') {
        setAbortController(null);
        return null;
      }
      if (err instanceof Error) {
        if (onError) {
          onError(err);
        }
      }
      setError(err);
    } finally {
      mutateLoading(false);
    }
  }, [mutate, mutateLoading, api, extraMetadataRef, setAbortController, onResponse, onFinish, onError, setError]);
  const stop = useCallback(() => {
    if (abortController) {
      abortController.abort();
      setAbortController(null);
    }
  }, [abortController]);
  const setCompletion = useCallback(completion => {
    mutate(completion, false);
  }, [mutate]);
  const complete = useCallback(async (prompt, options) => {
    return triggerRequest(prompt, options);
  }, [triggerRequest]);
  const [input, setInput] = useState(initialInput);
  const handleSubmit = useCallback(() => {
    if (!input) return;
    return complete(input);
  }, [input, complete]);
  const handleInputChange = e => {
    setInput(e);
  };
  return {
    completion,
    complete,
    error,
    setCompletion,
    stop,
    input,
    setInput,
    handleInputChange,
    handleSubmit,
    isLoading
  };
}
//# sourceMappingURL=use-completion.js.map